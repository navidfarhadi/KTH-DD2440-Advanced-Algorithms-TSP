\documentclass[12pt]{article}

% Packages
\usepackage[english]{babel}
\usepackage{natbib}
\usepackage{url}
\usepackage[table]{xcolor}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{vmargin}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{array}
\usepackage{amssymb}
\usepackage{pgfgantt}
\usepackage{tikz}
%\usepackage{pgfplots}
\usepackage{algpseudocode}
\usepackage{algorithm}
%\usepackage[ngerman]{datetime}

% Mark the meta information
\title{Project TSP Report}
\author{Farhadi, Fuchs, Kurzemnieks, and Peinot}																
\date{8 Mai 2015}

% Overwrite the english settings with german 
\addto\captionsenglish {
  \renewcommand{\contentsname}{Inhalt}
}
%\newdateformat{germanformat}{\THEDAY{. }\monthnamengerman[\THEMONTH], \THEYEAR}

% Set the layout
\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother
\graphicspath{{../../images/}}
\setmarginsrb{3 cm}{2.5 cm}{3 cm}{2.5 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}


% Mark the headers and footers
\pagestyle{fancy}
\fancyhf{}
\rhead{\theauthor}
\lhead{\thetitle}
\cfoot{\thepage}

% reformat tables
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}
\newcolumntype{N}{@{}m{0pt}@{}}

% Remove the ugly borders around the hyperlinks
\hypersetup{
    colorlinks,
    linkcolor={blue!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}

\newenvironment{equationate}{%
 \itemize
 \let\orig@item\item
 \def\item{\orig@item[]\refstepcounter{equation}\def\item{\hfill(\theequation)\orig@item[]\refstepcounter{equation}}}
}{%
 \hfill(\theequation)%
 \enditemize
}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Cover Page %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
	\centering
	\includegraphics[scale = 0.5]{KTH_Logo.jpg}\\[1.0 cm]
    \textsc{\LARGE KTH Royal Institute of Technology}\\[0.25 cm]
    \textsc{School of Electrical Engineering and Computer Science}\\[1.0 cm]
	
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
	{ \huge \bfseries \thetitle}\\
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
	
	
	

	\today\\[0.10 cm]
	\textsc{Autumn Term 2018}\\[0.80 cm]
	\textsc{Navid Farhadi}\\[0.10 cm]
	\textsc{Franz Fuchs}\\[0.10 cm]
	\textsc{Arturs Kurzemnieks}\\[0.10 cm]
	\textsc{Alexandre Peinot}\\[3.0 cm]

	\textsc{Kattis submission ID: 3520421 (score: 35.02778)}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Table of contents %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

Given a set of $n$ cities and the distances between them, the Travelling Salesman Problem (TSP) consists in finding the shortest circuit visiting all the cities only once. In this project, we study the Euclidian version of TSP in two dimensions. In this variant of the problem, all the cities are represented by their coordonnates $x$ and $y$ and the distance between two cities is the Euclidian distance between them (rounded to the nearest integer in the case of the project). 

This report present the different algorithm we have implemented for obtaining the initial tour of this problem and for optimizing it.  It shows the results obtained and compare the performance of the different solutions. 

\section{Implementation}

\subsection{Initial Tour}

\subsubsection{Christofides' Algorithm}

The algorithm of Christofides is not a brandnew invention.
It is an approximation algorithm that achieves to find a tour
with worst case length $ALG \leq 1.5 \cdot OPT$. The Christofides
algorithm consists of major parts that are explained in the following
text.

\textbf{Construction of a Minimum Spanning Tree}

A Minimum Spanning Tree (MST) is subset of edges in a graph that produces
a fully connected graph with minimum weight. It is important to note that there
does not have to be a unique solution for the MST problem. There can be
multiple sets of edges, which lead to equal total cost.
There are several algorithms to
solve that problem. The most common ones need $O(m \cdot log(n))$
time. One example is the algorithm of Prim. We decided to implement
this one because one member of our group had previous experience with that algorithm.
The algorithm of Prim has an initial node and creates the tree
originating from that node. Once a vertex is processed the shortest
path has been found and the incoming edge is added to the set of MST edges.
Prim's algorithm is fairly simple to implement in C++ because
the algorithm is based on a priority queue. The standard library
for C++ offers various structs to use out of the box. We decided
to use the \texttt{std::make\_heap} function in combination
with the basic data structure \texttt{std::vector<std::pair<int,double>>} and a comparator struct
that puts the smallest reachable vertex on the top of the heap.

\textbf{Finding of Vertices with Odd Degree}

After finding one solution for the MST problem, the algorithm of Christofides
says to sort out all the vertices that do not have an odd degree in the MST
edges set. This check can be done in $O(m + n)$. First we iterate over all
MST edges and increase for the two vertices the degree. After that, we sort
out all vertices with an even degree. Since the amount of MST edges is always
less equal than the amount vertices, we can simplify the runtime of finding
all odd vertices to $O(n)$. The formula $E_{MST} \le n$ holds because
of the construction criterion of MST.

\subsubsection{Nearest Neighbor}

An initial tour can also be found with the nearest neighbor approach.
Starting from a random initial vertex, the next vertex is determined
in the following way:

\begin{itemize}
	\item Compute the distance to each vertex that has not been visited yet
	\item Choose the vertex with the minimum distance
\end{itemize}

It can be shown that this approach leads to a tour with worst case length
$ALG \le 2 \cdot OPT$. Our implementation of the nearest neighbor algorithm
has a runtime of $O(n^2)$ because there is an iteration over all vertices
and another nested iteration over all vertices to find the one with
the minimum distance to the current vertex.

\subsubsection{Multiple Fragment}

The Multiple Fragment (MF) approach also promises to give a good initial tour,
but cannot hold as tight bounds as the algorithm of Christofides. The MF approach
is based on calculating all edges and sorting them from the lowest weight to
the highest one. Starting with the edge that has the lowest weight edges are picked
and put into the solution set of edges if they do not create circle in the solution
domain. Moreover, each vertex is only allowed to have one incoming and one outgoing
edge. In that way, our implementation of the MF approach has a runtime of $O(n^3)$
because it is possible to have to iterate through all edges and to check at the last
edge an circle of length $(n-1)$.

\subsection{Optimization}

After the obtention of the initial tour, we need to run some optimization algorithm to get as close as possible from the optimal solution. In our project, we have focus our work on three special cases of k-opt: 2-opt, 2H-opt and 3-opt. All of these algorithms belong to the class of local search algorithms. The main issue with these algorithms is that they can easily fall in some local minimum and then never obtain the optimal path. 

In practice, these algorithms must run until there is no new improvment. However, due to the Kattis time constraint, we have set a limit in the time execution in order to get the best possible path in the allowed time.

\subsubsection{2-opt}

The concept of the 2-opt algorithm is really simple. It basically consits in breaking two different edges of the tour and reconnecting the two obtained part of the tour in a way that minimize the distances. In this case, there are only two way of reconnecting the tour. The complete 2-opt algorithm iterates over all the possible pair of edge cutting in the tour.

Our implementation of the algorithm is $O(n²)$ because it iterates through all pair of edge cutting. However, it is quite fast as it only evaluate the distances which could change by reversing the path between the two cuts and do the reverse only if it improves the tour's distance.

\subsubsection{2H-opt}

\subsubsection{3-opt}

The 3-opt optimization consists in cutting 3 different edges of the path and concerving the shortest circuit over the 8 possibilities of reconnecting the three obtained part of the tour. The complete 3-opt algorithm iterates over all the possible set of 3 edge cutting in the tour. Thus, one execution of the algorithm is $O(n³)$. Once again, we only evaluate, the distances which could change when reconnecting the circuit.

\section{Evaluation}

\section{Conclusion}

The Travelling Salesman Problem is a really simple problem in its formulation but it can be very difficult to find an optimal tour by using limited ressources (time, memory). That is why it is important to compute quickly an initial tour that is quite close to the optimal solution and choose well the optimization algorithms to use to go efficiently to the optimal tour.

\section{References}

\end{document}
