\documentclass[12pt]{article}

% Packages
\usepackage[english]{babel}
\usepackage{url}
\usepackage[table]{xcolor}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{vmargin}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{array}
\usepackage{amssymb}
\usepackage{pgfgantt}
\usepackage{tikz}
%\usepackage{pgfplots}
\usepackage{algpseudocode}
\usepackage{algorithm}
%\usepackage[ngerman]{datetime}
%\usepackage{minted}
%\usemintedstyle{vs}

% Mark the meta information
\title{Project TSP Report}
\author{Farhadi, Fuchs, Kurzemnieks, and Peinot}																
\date{8 Mai 2015}

% Overwrite the english settings with german 
\addto\captionsenglish {
  \renewcommand{\contentsname}{Inhalt}
}
%\newdateformat{germanformat}{\THEDAY{. }\monthnamengerman[\THEMONTH], \THEYEAR}

% Set the layout
\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother
\graphicspath{{../../images/}}
\setmarginsrb{3 cm}{2.5 cm}{3 cm}{2.5 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}


% Mark the headers and footers
\pagestyle{fancy}
\fancyhf{}
\rhead{\theauthor}
\lhead{\thetitle}
\cfoot{\thepage}

% reformat tables
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}
\newcolumntype{N}{@{}m{0pt}@{}}

% Remove the ugly borders around the hyperlinks
\hypersetup{
    colorlinks,
    linkcolor={blue!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}

\newenvironment{equationate}{%
 \itemize
 \let\orig@item\item
 \def\item{\orig@item[]\refstepcounter{equation}\def\item{\hfill(\theequation)\orig@item[]\refstepcounter{equation}}}
}{%
 \hfill(\theequation)%
 \enditemize
}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Cover Page %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
	\centering
	\includegraphics[scale = 0.5]{KTH_Logo.jpg}\\[1.0 cm]
    \textsc{\LARGE KTH Royal Institute of Technology}\\[0.25 cm]
    \textsc{School of Electrical Engineering and Computer Science}\\[1.0 cm]
	
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
	{ \huge \bfseries \thetitle}\\
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
	
	
	

	\today\\[0.10 cm]
	\textsc{Autumn Term 2018}\\[0.80 cm]
	\textsc{Navid Farhadi}\\[0.10 cm]
	\textsc{Franz Fuchs}\\[0.10 cm]
	\textsc{Arturs Kurzemnieks}\\[0.10 cm]
	\textsc{Alexandre Peinot}\\[3.0 cm]

	\textsc{Kattis submission ID: 3520421 (score: 35.02778)}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Table of contents %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

Given a set of $n$ cities and the distances between them, the Traveling Salesman Problem (TSP) consists in finding the shortest circuit visiting all the cities only once. In this project, we study the Euclidean version of TSP in two dimensions \cite{course}. In this variant of the problem, all the cities are represented by their coordinates $x$ and $y$ and the distance between two cities is the Euclidean distance between them (rounded to the nearest integer in the case of the project). 

This report present the different algorithm we have implemented for obtaining the initial tour of this problem and for optimizing it.  It shows the results obtained and compare the performance of the different solutions. 

\section{Implementation}

\subsection{Initial Tour}

\subsubsection{Christofides' Algorithm}

In comparison to other many other useful algorithms in the field of TSP algorithms,
the algorithm of Christofides \cite{christofides} was invented over 40 years ago.
It is an approximation algorithm that achieves to find a tour
with worst case length $ALG \leq 1.5 \cdot OPT$. The Christofides
algorithm consists of four major parts that are explained in the following
text.

\textbf{Construction of a Minimum Spanning Tree}

A Minimum Spanning Tree (MST) is a subset of edges in a graph that produces
a fully connected graph with minimum weight. It is important to note that there
does not have to be a unique solution for the MST problem. There can be
multiple sets of edges, which lead to equal total cost.
There are several algorithms to
solve that problem. The most common ones need $O(m \cdot log(n))$
time. One example is the algorithm of Prim. We decided to implement
this one because one member of our group had previous experience with that algorithm.
The algorithm of Prim has an initial node and creates the tree
originating from that node. Once a vertex is processed the shortest
path has been found and the incoming edge is added to the set of MST edges.
Prim's algorithm is fairly simple to implement in C++ because
the algorithm is based on a priority queue. The standard library
for C++ offers various structs to use out of the box. We decided
to use the \texttt{std::make\_heap} function in combination
with the basic data structure \texttt{std::vector<std::pair<int,double>>} and a comparator struct
that puts the smallest reachable vertex on the top of the heap.

\textbf{Finding of Vertices with Odd Degree}

After finding one solution for the MST problem, the algorithm of Christofides
says to sort out all the vertices that do not have an odd degree in the MST
edges set. This check can be done in $O(m + n)$. First, we iterate over all
MST edges and increase for the two vertices the degree. After that, we sort
out all vertices with an even degree. Since the amount of MST edges is always
less equal than the amount vertices, we can simplify the runtime of finding
all odd vertices to $O(n)$. The formula $|E_{MST}| \le n$ holds because
of the construction criterion of MST.

\textbf{Minimum-weight Perfect Matching}

The next step of Christofides involves finding a minimum-weight perfect matching for
the odd-degree subgraph acquired in the previous step. A perfect matching for a graph
is a set of edges so that no vertices are shared between the edges but all vertices are covered, i.e.,
every vertex is covered by exactly one edge in the matching. By the Handshaking lemma, the odd-degree
subgraph from the previous step must have an even number of vertices, therefore no vertices are left
without a pairing and a perfect matching is always possible.
As multiple different matchings can be possible, the aim of this step is to produce a minimum-weight matching
with the least total cost of the edges.

Since this is a very complex problem, we opted to use an existing and publicly available implementation\footnote{as autorized in the hints of the TSP project}
of the Edmond's Blossom algorithm. This implementation, called \textit{Blossom V}, was described and developed 
by Vladimir Kolmogorov and follows a $O(n^2m)$ time bound \cite{kolmogorov}\cite{kolmogorovcode}. We incorporated it into our codebase
in a trimmed and minimized form, adding a wrapper function to map between the input and output format of the
implementation and the data structures used by us.

Finally an Eulerian multigraph is constructed as a union $T \cup M$ of the perfect matching $M$ and the previously 
obtained minimum spanning tree $T$. Given our choice of data structures, the union can easily be implemented
as a concatenation of the two vectors representing the perfect matching and MST.

\textbf{Eulerian Circuit \& Algorithm Output}

The final two steps of Christofides algorithm required us to implement an algorithm to check whether or not the given multigraph $T \cup M$ contains an Eulerian circuit. Prior to doing this, the data structure containing the graph $T \cup M$ is modified from \texttt{vector<array<int,2>>} to \texttt{unordered\_map<int,vector<int>>}. This is a basic implementation of a seperate chaining hash table. The reason that we made the decision to do this is because \texttt{unordered\_map} has $O(1)$ look-ups which is useful when checking to see whether or not the graph contains an Eulerian circuit and finding the Eulerian circuit.

Next, we wrote a function to check whether or not the graph contains an Eulerian circuit. This was straightforward since we just needed to check whether or not each vertex has an even degree, since a graph contains an Eulerian circuit if and only if all vertices have an even degree. If the graph contains an Eulerian circuit, then we find the Eulerian circuit. This function was useful when testing our algorithm. In Christofides algorithm, $T \cup M$ is guaranteed to be given to you as an Eulerian multigraph so it isn't necessary to utilize this function in our final implementation, but we found that it did not effect the kattis score so we decided to keep it.

To find the Eulerian circuit we used a simple algorithm that runs in $O(n+m)$ \cite{graphmagics}. Once we have an Eulerian circuit, we simply removed all repeated vertices which takes $O(n)$ time to give us the output of the algorithm as a hamiltonian circuit of the original input graph to TSP.

\subsubsection{Nearest Neighbor}

An initial tour can also be found with the nearest neighbor approach.
Starting from a random initial vertex, the next vertex is determined
in the following way:

\begin{itemize}
	\item Compute the distance to each vertex that has not been visited yet
	\item Choose the vertex with the minimum distance
\end{itemize}

It can be shown that this approach leads to a tour with worst case length
$ALG \le 2 \cdot OPT$. Our implementation of the nearest neighbor algorithm
has a runtime of $O(n^2)$ because there is an iteration over all vertices
and another nested iteration over all vertices to find the one with
the minimum distance to the current vertex.

\subsubsection{Multiple Fragment}

The Multiple Fragment (MF) approach also promises to give a good initial tour,
but cannot hold as tight bounds as the algorithm of Christofides. The MF approach
is based on calculating all edges and sorting them from the lowest weight to
the highest one. Starting with the edge that has the lowest weight edges are picked
and put into the solution set of edges if they do not create circle in the solution
domain. Moreover, each vertex is only allowed to have one incoming and one outgoing
edge. In that way, our implementation of the MF approach has a runtime of $O(n^3)$
because it is possible to have to iterate through all edges and to check at the last
edge an circle of length $(n-1)$ \cite{tum-chris-mf}.

\subsection{Optimization}

After the obtention of the initial tour, we need to run some optimization algorithm to get as close as possible to the optimal solution. In our project, we have focus our work on three special cases of k-opt: 2-opt, 2H-opt and 3-opt. All of these algorithms belong to the class of local search algorithms \cite[p.~133]{course}. The main issue with these algorithms is that they can easily fall in some local minimum and then never obtain the optimal path. 

In practice, these algorithms must run until there is no new improvement. However, due to the Kattis time constraint, we have set a limit in the time execution in order to get the best possible path in the allowed time.

\subsubsection{2-opt}

The concept of the 2-opt algorithm is really simple. It basically consists in breaking two different edges of the tour and reconnecting the two obtained part of the tour in a way that minimize the distances. In this case, there are only two way of reconnecting the tour. The complete 2-opt algorithm iterates over all the possible pair of edge cutting in the tour.

Our implementation of the algorithm is $O(n²)$ because it iterates through all pair of edge cutting. However, it is quite fast as it only evaluate the distances which could change by reversing the path between the two cuts and do the reverse only if it improves the tour's distance.

\subsubsection{2H-opt}

Also called 2.5-opt, this algorithm looks for sets of three vertices $\{t,u,v\}$ in the path and tries relocating the 
middle vertex $u$ between some other two vertices $\{x, z\}$, and evaluating whether the new triad $\{x, u, z\}$ and
directly connected $\{t,v\}$ are resulting in a shorter total path.

Our implementation iterates through all triads of the path, for each additionally iterating through the possible pairs
for it to be compared against, resulting in $O(n^2)$ running time. As with 2-opt, the distance evaluation itself is quite fast,
but modifying the tour if a movable vertex is found is considerably more expensive. As a vector is being used for representation
of the path, vertex $u$ must be deleted from it, resulting in shifting of elements after its position. It is then
reinserted between $x$ and $z$, again shifting elements $z$ and upwards.


\subsubsection{3-opt}

The 3-opt optimization consists in cutting 3 different edges of the path and concerving the shortest circuit over the 8 possibilities of reconnecting the three obtained part of the tour. The complete 3-opt algorithm iterates over all the possible set of 3 edge cutting in the tour. Thus, one execution of the algorithm is $O(n³)$. Once again, we only evaluate, the distances which could change when reconnecting the circuit.

\section{Evaluation}

In the following part, we will evaluate how successful the different parts of the implementation
have been and where we had major problems. Concerning the test cases, we use locally some small basic test cases for debugging and we evaluate the performances based on kattis score.

\subsection{Initial Tour}

Computing the initial tour has a major impact on how good our results on kattis are.
This means that we optimally should not use a lot of time but still
get a good approximation. The actual score is determined by the optimization, which
are conducted afterwards. We
implemented all the approaches described above to get an initial tour and
compared them by their kattis score.
It is important to note that we have always applied the same optimization strategy so that the results
are comparable. The algorithm of Chrisofides performed best among all algorithms. This is mainly
determined by the fact that Christofides' algorithm is bound to a factor of $1.5$ of the optimal
solution. In this way, the kattis score is remarkably higher than for the other two approaches.
The algorithm of Christofides has one major drawback. Its implementation is not simple because of the
difficulty of implementing the computation of a MST and of the perfect matching.
This has cost us a lot of time during the implementation
phase, but it was worth it measured by the increase of the kattis score it gave.

\subsection{Optimization}

After obtaining a good initial tour, it is important to optimize it in order to get the best possible kattis score. The following comparison of results is obtained with an initial tour from Christofides' algorithm which gives us the best results.
First, we have implemented 2-opt and try to optimize our path by running 2-opt until the end of the allowaded time (2s). We obtained at most 25 points on kattis by making the algorithm as fast as possible. Then, to improve our score, we implemented 3-opt and get around 28-29 points by running only 3opt. As the cost of 3-opt is quite expensive, we have implemented 2H-opt and tried to find a compromise between running 2-opt, 2H-opt and 3-opt. We obtained our best score of 35 by running a combination of the three algorithms. In fact, we run a loop of 2-opt and 2H-opt until 1.05 seconds of the total running time in order to do a first fast optimization, and then, we run a loop of 2H-opt and 3-opt until the end of the allowed time in order to obtain a more precise optimization. 

\section{Conclusion}

The Traveling Salesman Problem is a really simple problem in its formulation but it can be very difficult to find an optimal tour by using limited resources (time, memory). That is why it is important to compute quickly an initial tour that is quite close to the optimal solution and choose well the optimization algorithms to use to go efficiently to the optimal tour.

\medskip
\newpage
\begin{thebibliography}{9}
	\bibitem{kolmogorov}
	Vladimir Kolmogorov. "Blossom V: A new implementation of a minimum cost perfect matching algorithm."
	In Mathematical Programming Computation (MPC), July 2009, 1(1):43-67.
	\bibitem{kolmogorovcode}
	Vladimir Kolgomorov. Blossom V source code (licensed for research purposes only), Retrieved December 4, 2018, from \url{http://pub.ist.ac.at/~vnk/software/blossom5-v2.05.src.tar.gz}
	\bibitem{graphmagics}
	Dumitru Ciubatii. "Eulerian Path and Circuit." Retrieved November 15, 2018, from \url{http://www.graphmagics.com/articles/euler.php}.
	\bibitem{tum-chris-mf}
	Sebastian Lotz. "Lösung and graphische Darstellung des Travelling Salesman Problems in einer Webapplikation.", Retrieved November 25, 2018, from \url{https://mediatum.ub.tum.de/doc/1225159/1225159.pdf}.
	\bibitem{christofides}
		Nicos Christofides. "Worst Case Analysis of a New Heuristic for the Traveling Salesman Problem.", Retrieved November 27, 2018, from \url{https://apps.dtic.mil/dtic/tr/fulltext/u2/a025602.pdf}.
	\bibitem{course}
		Johan Hastad. "Notes for the course advanced algorithms", January 2000, 16:129-141
\end{thebibliography}


\end{document}
